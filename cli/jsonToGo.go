package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"strings"
	"unicode"
)

type StructDefinition struct {
	Name   string
	Fields []FieldDefinition
}

type FieldDefinition struct {
	Name       string
	Type       string
	JSONTag    string
	BSONTag    string
	Validation string
}

func main() {
	inputFile := flag.String("input", "", "Input JSON file")
	outputFile := flag.String("output", "", "Output Go file")
	packageName := flag.String("package", "main", "Package name for generated code")
	structName := flag.String("name", "AutoGenerated", "Name for the root struct")
	flag.Parse()

	if *inputFile == "" || *outputFile == "" {
		fmt.Println("Please provide input and output file paths")
		flag.Usage()
		os.Exit(1)
	}

	// Read and parse JSON
	jsonData, err := ioutil.ReadFile(*inputFile)
	if err != nil {
		fmt.Printf("Error reading input file: %v\n", err)
		os.Exit(1)
	}

	var data map[string]interface{}
	if err := json.Unmarshal(jsonData, &data); err != nil {
		fmt.Printf("Error parsing JSON: %v\n", err)
		os.Exit(1)
	}

	// Generate code
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("package %s\n\n", *packageName))
	buf.WriteString("import (\n\t\"time\"\n)\n\n")

	structs := make(map[string]*StructDefinition)
	parseStruct(*structName, data, structs)

	// Write all struct definitions
	for _, st := range structs {
		generateStructCode(&buf, st)
	}

	// Format and write the code
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("Error formatting code: %v\n", err)
		os.Exit(1)
	}

	if err := ioutil.WriteFile(*outputFile, formattedCode, 0644); err != nil {
		fmt.Printf("Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Successfully generated struct definitions")
}

func ParseStruct(name string, data map[string]interface{}, structs map[string]*StructDefinition) *StructDefinition {
	st := &StructDefinition{
		Name:   name,
		Fields: make([]FieldDefinition, 0),
	}
	structs[name] = st

	for key, value := range data {
		field := FieldDefinition{
			Name:    toGoFieldName(key),
			JSONTag: key,
			BSONTag: key,
		}

		switch v := value.(type) {
		case map[string]interface{}:
			if val, ok := v["value"]; ok {
				// Handle fields with validation
				field.Type = getGoType(val)
				if validationRule, ok := v["validation"].(string); ok {
					field.Validation = validationRule
				}
			} else {
				// Handle nested struct
				nestedName := fmt.Sprintf("%s%s", name, field.Name)
				ParseStruct(nestedName, v, structs)
				field.Type = nestedName
				field.Validation = "required"
			}
		default:
			field.Type = getGoType(value)
			field.Validation = getDefaultValidation(field.Type, key)
		}

		st.Fields = append(st.Fields, field)
	}

	return st
}

func GenerateStructCode(buf *bytes.Buffer, st *StructDefinition) {
	buf.WriteString(fmt.Sprintf("type %s struct {\n", st.Name))
	for _, field := range st.Fields {
		tags := fmt.Sprintf("`json:\"%s\" bson:\"%s\"", field.JSONTag, field.BSONTag)
		if field.Validation != "" {
			tags += fmt.Sprintf(" validate:\"%s\"", field.Validation)
		}
		tags += "`"
		buf.WriteString(fmt.Sprintf("\t%s %s %s\n", field.Name, field.Type, tags))
	}
	buf.WriteString("}\n\n")
}

func GetGoType(v interface{}) string {
	switch val := v.(type) {
	case bool:
		return "bool"
	case float64:
		if val == float64(int64(val)) {
			return "int"
		}
		return "float64"
	case string:
		if strings.Contains(val, "T") && strings.Contains(val, "Z") {
			return "time.Time"
		}
		return "string"
	case []interface{}:
		if len(val) > 0 {
			return "[]" + GetGoType(val[0])
		}
		return "[]interface{}"
	case nil:
		return "interface{}"
	default:
		return "interface{}"
	}
}

func GetDefaultValidation(fieldType, fieldName string) string {
	var validations []string

	validations = append(validations, "required")

	switch {
	case fieldType == "string":
		if strings.Contains(strings.ToLower(fieldName), "email") {
			validations = append(validations, "email")
		} else if strings.Contains(strings.ToLower(fieldName), "url") {
			validations = append(validations, "url")
		} else {
			validations = append(validations, "max=255")
		}
	case fieldType == "int":
		validations = append(validations, "gte=0")
	case fieldType == "time.Time":
		validations = append(validations, "datetime")
	}

	return strings.Join(validations, ",")
}

func ToGoFieldName(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		switch strings.ToLower(p) {
		case "url":
			parts[i] = "URL"
		case "id":
			parts[i] = "ID"
		default:
			r := []rune(p)
			if len(r) > 0 {
				r[0] = unicode.ToUpper(r[0])
			}
			parts[i] = string(r)
		}
	}
	return strings.Join(parts, "")
}

